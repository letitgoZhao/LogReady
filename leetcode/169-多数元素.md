# 169. 多数元素

> [题目链接](https://leetcode.cn/problems/majority-element/?envType=study-plan-v2&envId=top-interview-150)

## 初次尝试

```cpp
int majorityElement(int* nums, int numsSize) {
    int var1 = 0, var2 = 0;
    unsigned int count = 1;

    for (var1 = 0; var1 < numsSize; ++var1) {
        for (var2 = var1 + 1; var2 < numsSize; ++var2){
            if (nums[var2] == nums[var1]){
                // 迭代
                ++count;
            }
        }
        if (count > (numsSize / 2))
            return nums[var1];
        // 重新开始计算
        count = 1;
    }
    return -1;
}
```
时间复杂度较高，不合理。

## 较合理的解法1-排序求众数

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums);
};

int Solution :: majorityElement(vector<int>& nums) {
    // 默认O(nlgn)的排序算法
    sort(nums.begin(), nums.end());
    // 由于需要返回大于nums.size() / 2, 因而即为求众数
    // 直接返回众数的下标
    return nums[nums.size() / 2];
}
```

## 分治算法

```cpp
class Solution {
    int count_in_range(vector<int>& nums, int target, int lo, int hi) {
        int count = 0;
        for (int i = lo; i <= hi; ++i)
            if (nums[i] == target)
                ++count;
        return count;
    }
    int majority_element_rec(vector<int>& nums, int lo, int hi) {
        // 单个值即为"众数"
        if (lo == hi)
            return nums[lo];
        int mid = (lo + hi) / 2;
        // 向左递归得到最多数元素
        int left_majority = majority_element_rec(nums, lo, mid);
        // 向右递归得到最多数元素
        int right_majority = majority_element_rec(nums, mid + 1, hi);

        // 多数列表判断众数
        if (count_in_range(nums, left_majority, lo, hi) > (hi - lo) / 2)
            return left_majority;
        if (count_in_range(nums, right_majority, lo, hi) > (hi - lo) / 2)
            return right_majority;
        
        return -1;
    }
public:
    int majorityElement(vector<int>& nums) {
        return majority_element_rec(nums, 0, nums.size() - 1);
    }
};
```