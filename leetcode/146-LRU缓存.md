# 146. LRU缓存

> [题目链接](https://leetcode.cn/problems/lru-cache/?envType=study-plan-v2&envId=top-interview-150)

## 哈希表+双端链表
采用`哈希表和一个双向链表`来维护所有在缓存中的`键值对`。
- 双向链表按照使用顺序存储这些键值对，`靠近头部的键值对最近使用，靠近尾部的键值对不常使用`，采用双向链表可以方便管理。
- 哈希表定位，找到缓存项所在的位置，然后将其移动到双向链表的头部，进行`o(1)`时间的`get`和`put`操作。
- 对于`put`操作：先判断`key是否存在`。若存在，将对应结点的值更新，并将该结点移动到双向链表的头部；若不存在，使用key-value创建新结点，并在双向链表的头部加入该结点，并记得在哈希表中加入元素，最后判断双向链表的长度是否超出容量的限制，如果超出了限制就删除双向链表的尾结点，同时清空哈希表元素。
- 对于`get`操作，如果key不存在，直接返回-1；如果key存在，定位结点位置，然后将其移动到双向链表的头部，最后返回参数数值即可。

```cpp
/* 双端链表结构 */
struct DLinkedNode {
    int key;
    int value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode() : key(0), value(0), prev(nullptr), next(nullptr) {}
    DLinkedNode(int key_, int value_)
        : key(key_), value(value_), prev(nullptr), next(nullptr) {}
};

class LRUCache {
public:
    LRUCache(int capacity_) : capacity(capacity_), size(0) {
        // 虚拟头结点和虚拟尾结点
        this->head = new DLinkedNode();
        this->tail = new DLinkedNode();
        this->head->next = tail;
        this->tail->prev = head;
    }

    int get(int key) {
        if (!cache.count(key)) {
            // 在LRUCache中未找到key
            return -1;
        }
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }

    void put(int key, int value) {
        if (!cache.count(key)) {
            // 创建新的结点
            DLinkedNode* node = new DLinkedNode(key, value);
            // cache中加入node
            cache[key] = node;
            // node结点移动到头部
            addToHead(node);
            this->size++;
            if (size > capacity) {
                // 删除双向链表的尾部结点
                DLinkedNode* remove = removeTail();
                // 哈希表中删除键值
                cache.erase(remove->key);
                // 防止内存泄露
                delete remove;
                this->size--;
            }
        } else {
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }

private:
    /* -------------------- 类存储变量数据 -------------------- */
    // 初始容量大小
    int capacity;
    // 当前尺寸大小
    int size;
    // 哈希表+双端链表实现o(1)查找算法
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head;
    DLinkedNode* tail;

    /* ---------------------- 操作函数 ---------------------- */
    // 1. 头插元素
    void addToHead(DLinkedNode* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    // 2. 删除指定结点元素
    void removeNode(DLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    // 3. 双端链表中的元素移动到开头
    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }
    // 4. 尾删元素
    DLinkedNode* removeTail(void) {
        DLinkedNode* node = tail->prev;
        removeNode(node);
        return node;
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```