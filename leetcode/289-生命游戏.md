# 289. 生命游戏

> [题目链接](https://leetcode.cn/problems/game-of-life/?envType=study-plan-v2&envId=top-interview-150)

## 规则模拟

时间复杂度`o(mn)`，空间复杂度`o(mn)`。

```cpp
class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        // 时间复杂度o(mn), 空间复杂度o(mn).
        // board不为空
        int row = board.size() - 1;
        int col = board[0].size() - 1;
        int nums = 0;
        // 需要拷贝一个复制品, 因为修改值了
        auto copy = board;
        for (int i = 0; i <= row; i++) {
            for (int j = 0; j <= col; j++) {
                // 记录活细胞的数目
                nums = 0;
                // 边界索引值
                int l = j - 1, r = j + 1;
                int u = i - 1, d = i + 1;
                // 检测边界是否合法
                bool l_flag = (l >= 0) ? true : false;
                bool r_flag = (r <= col) ? true : false;
                bool u_flag = (u >= 0) ? true : false;
                bool d_flag = (d <= row) ? true : false;

                // 计算nums的规则[1. 左侧三个 2. 右侧三个 3. 上侧 4. 下侧]
                if (l_flag) {
                    nums += copy[i][l];
                    if (u_flag)
                        nums += copy[u][l];
                    if (d_flag)
                        nums += copy[d][l];
                }
                if (r_flag) {
                    nums += copy[i][r];
                    if (u_flag)
                        nums += copy[u][r];
                    if (d_flag)
                        nums += copy[d][r];
                }
                if (u_flag) {
                    nums += copy[u][j];
                }
                if (d_flag) {
                    nums += copy[d][j];
                }

                // 判断细胞死亡与否的规则
                if (copy[i][j] == 1 && (nums < 2 || nums > 3))
                    board[i][j] = 0;
                if (copy[i][j] == 0 && nums == 3)
                    board[i][j] = 1;
                // 规则2不用管, 存活->存活
            }
        }
    }
};
```