# 150. 逆波兰表达式求值

> [题目链接](https://leetcode.cn/problems/evaluate-reverse-polish-notation/?envType=study-plan-v2&envId=top-interview-150)

逆波兰表达式：

- 逆波兰表达式是一种*后缀表达式*，所谓后缀就是指算符写在后面。

- *平常使用的算式则是一种中缀表达式*，如 ( 1 + 2 ) * ( 3 + 4 ) 。
- 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
- 逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
- 解题思路：`适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中`。

## 题解1——栈结构
时间复杂度o(n), 空间复杂度o(n)。

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        // 创建栈结构
        stack<int> st;

        // 1. 操作符和操作数均有效, 因而需要实现o(n)的遍历.
        for (int i = 0; i < tokens.size(); ++i) {
            string& token = tokens[i];
            if (isNumber(token)) {
                // 如果遍历到数字, 就压栈
                st.push(std::atoi(token.c_str()));  // 注意API调用
            } else {
                // 如果遍历到运算符, 就执行对应的操作

                // 1. 先拿到操作数2
                int num2 = st.top();
                st.pop();
                // 2. 再拿到操作数1
                int num1 = st.top();
                st.pop();

                // 3. 操作数1 opera 操作数2 -> 下一个左操作数(入栈操作) ->
                // 下一次迭代用
                switch (token.at(0)) {
                case '+':
                    st.push(num1 + num2);
                    break;
                case '-':
                    st.push(num1 - num2);
                    break;
                case '*':
                    st.push(num1 * num2);
                    break;
                case '/':
                    st.push(num1 / num2);
                    break;
                }
            }
        }
        return st.top();
    }

    bool isNumber(string& token) {
        // token是一个+、-*、/ 或者[-200, 200]的整数
        return !(token == "+" || token == "-" || token == "*" || token == "/");
    }
};
```