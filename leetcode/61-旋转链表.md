# 61. 旋转链表

> [题目链接](https://leetcode.cn/problems/rotate-list/?envType=study-plan-v2&envId=top-interview-150)

## 初次尝试——哨兵结点+取模运算
算法原理：增加哨兵位来方便控制位移次数以及后续的链接操作。通过取模运算来计算出实际的位移次数，通过位移次数来决定怎么链接，是保持``head``，还是分为两个链表进行链接。
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        // 处理特殊情况1
        if (head == nullptr || head->next == nullptr || k == 0)
            return head;
        ListNode* dummy_head = new ListNode(-1, head);
        ListNode* cur = dummy_head;
        // 求解实际移动次数
        int len = length(head);
        int valid = (k < len) ? k : k % len;
        // '两个链表' - '反转一个', 这是一般情况
        // 以 [-1]-[1, 2, 3, 4, 5] 为例来理解实现算法
        if (valid == 0)
            // 特殊情况2, null pointer exception, 因为肯定到最后了, '回旋'
            return head;
        for (int i = 0; i < len - valid; ++i) {
            cur = cur->next;
        } // 找到'3'
        ListNode* start_node = cur->next;
        ListNode* new_node = start_node;
        cur->next = nullptr;
        // 找到'nullptr'
        while (new_node->next != nullptr) {
            new_node = new_node->next;
        }
        new_node->next = dummy_head->next;

        return start_node;
    }

private:
    int length(ListNode* head) {
        int len = 0;
        while (head != nullptr) {
            len++;
            head = head->next;
        }
        return len;
    }
};
```