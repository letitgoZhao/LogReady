# 21. 合并两个有序链表

> [题目链接](https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-interview-150)

## 迭代方法+哨兵结点
首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。
在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 头节点, 调用构造函数
        ListNode* head = new ListNode();
        // 尾节点-插入元素使用
        ListNode* tail = head;

        while (list1 != nullptr || list2 != nullptr) {
            if (list1 == nullptr) {
                // 解决某一个链表遍历完
                tail->next = list2;
                break;
            }
            if (list2 == nullptr) {
                // 解决某一个链表遍历完
                tail->next = list1;
                break;
            }
            // 一般的合并操作
            if (list1->val < list2->val) {
                // link and update
                tail->next = list1;
                list1 = list1->next;
            } else {
                // link and update
                tail->next = list2;
                list2 = list2->next;
            }
            tail = tail->next;
        }
        return head->next;
    }
};
```