# 122. 买卖股票的最佳时机II

> [题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/?envType=study-plan-v2&envId=top-interview-150)

## 贪心算法——思想：'赚了就卖', '不赚就跑'

这种算法相当于只考虑上升的股票，即若把股票走势看成折线图，仅仅取上升的点，保证稳赚不赔，遍历一遍相当于不遗漏。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 算法思想 
        // 设prices[i]表示当前天的股票价格, prices[i - 1]表示前一天的股票价格.
        // 只要 prices[i - 1] < prices[i], 执行卖股票, 赚取利润.
        // 这表示 i-1 天买入, i 天售出
        // 以此重复 i天买入, i+1天售出......
        int maxProfit = 0;
        for (int i = 1; i < prices.size(); ++i) {
            if (prices[i - 1] < prices[i])
                maxProfit += prices[i] - prices[i - 1];
        }
        return maxProfit;
    }
};
```


## 动态规划算法

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 动态规划算法:
        // * 每天交易结束后只可能 有一支股票 或者 没有股票的状态 *
        // dp[i][0] - 表示第i天交易完后手里 没有股票的最大利润.
        // dp[i][1] - 表示第i天交易完后手里 持有一支股票的最大利润.
        // 状态转移方程:
        // dp[i][0] = max{ dp[i - 1][0], dp[i - 1][1] + prices[i] }
        // dp[i][1] = max{ dp[i - 1][1], dp[i - 1][0] - prices[i] }
        // 初始状态:
        // dp[0][0] = 0
        // dp[0][1] = -prices[0]
        // 结果:(累加原因, 一定在最后)
        // 迭代填充dp, dp[sz - 1][0] > dp[sz - 1][1] ---> return dp[sz - 1][0]
        int sz = prices.size();
        int dp[sz][2];
        dp[0][0] = 0, dp[0][1] = -prices[0];

        for (int i = 1; i < sz; ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[sz - 1][0];
    }
};
```

改进后的算法实现, 优化了存储空间。
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 动态规划算法:
        // * 每天交易结束后只可能 有一支股票 或者 没有股票的状态 *
        // dp[i][0] - 表示第i天交易完后手里 没有股票的最大利润.
        // dp[i][1] - 表示第i天交易完后手里 持有一支股票的最大利润.
        // 状态转移方程:
        // dp[i][0] = max{ dp[i - 1][0], dp[i - 1][1] + prices[i] }
        // dp[i][1] = max{ dp[i - 1][1], dp[i - 1][0] - prices[i] }
        // 初始状态:
        // dp[0][0] = 0
        // dp[0][1] = -prices[0]
        // 结果:(累加原因, 一定在最后)
        // 迭代填充dp, dp[sz - 1][0] > dp[sz - 1][1] ---> return dp[sz - 1][0]
        int dp00 = 0, dp01 = -prices[0];

        for (int i = 1; i < prices.size(); ++i) {
            dp00 = max(dp00, dp01 + prices[i]);

            dp01 = max(dp01, dp00 - prices[i]);
        }
        return dp00;
    }
};
```