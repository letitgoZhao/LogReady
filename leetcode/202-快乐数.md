# 202. 快乐数

> [LeetCode题目链接](https://leetcode.cn/problems/happy-number/description/?envType=study-plan-v2&envId=top-interview-150)

## 初次尝试——通过（仅能跑通测试用例和通过题目）

```cpp
class Solution {
public:
    bool isHappy(int n) {
        int temp = 0; int count = 0;
        while (count <= 999) {
            temp = claculate(n);
            if (temp == 1)
                return true;
            else
                n = temp;
            count++;
        }
        return  false;
    }
private:
    int claculate(int n) {
        int ans = 0;
        string str_n = std::to_string(n);
        for (int i = 0; i < str_n.size(); ++i) {
            ans += (str_n[i] - '0') * (str_n[i] - '0');
        }
        return ans;
    }
    
};
```

## unordered_set容器使用——哈希表、快速检索方案

```cpp
class Solution {
    // 1. 最终会得到1
    // 2. 最终进入循环
    // 3. 值越来越大, 最后趋向于无穷大

    // 一位数: 9 -> 81, 最坏循环
    // 两位数: 99 -> 162, 最坏循环
    // 三位数: 999 -> 243, 最坏循环
    // ......  -> 情况三是不可能进行下去的, 最终要么循环, 要么得到1
public:
    bool isHappy(int n) {
        // 哈希表结构提供更快的检索方案o(1)
        unordered_set<int> hash;
        while (n != 1 && !hash.contains(n)) {
            hash.insert(n); // 插入不同的元素
            n = getNext(n); // 更新n的值
        }
        // n == 1时, 跳出 '循环'
        // 查询到重复元素时, 跳出循环, 判断
        return (n == 1);
    }

private:
    /* 数位分离, 求平方和 */
    int getNext(int n) {
        int sum = 0;
        while (n > 0) {
            int d = n % 10;
            n = n / 10;
            sum += d * d;
        }
        return sum;
    }
};
```

## 快慢指针检测 ’是否存在环形链表‘

```cpp
class Solution {
    // 1. 最终会得到1
    // 2. 最终进入循环
    // 3. 值越来越大, 最后趋向于无穷大

    // 一位数: 9 -> 81, 最坏循环
    // 两位数: 99 -> 162, 最坏循环
    // 三位数: 999 -> 243, 最坏循环
    // ......  -> 情况三是不可能进行下去的, 最终要么循环, 要么得到1
public:
    bool isHappy(int n) {
        // 通过反复条用getNext(), 得到的是一个 '隐式的链表'.
        // 因而 isHappy()函数的实现即为 '检测链表是否有环'的问题.
        // 采用快慢指针来判定该问题.
        // 116 -> 38 -> 73 ->  ** 58 -> 89 -> 145 -> 42 -> 20 -> 4 -> 16 -> 37 -> 58 ** 
        int slow = n;
        int fast = getNext(n);
        
        while (fast != 1 && fast != slow) {
            slow = getNext(slow);
            fast = getNext(getNext(fast));
        }

        return (fast == 1);
    }

private:
    /* 数位分离, 求平方和 */
    int getNext(int n) {
        // 特别地: 1->1->1->......
        int sum = 0;
        while (n > 0) {
            int d = n % 10;
            n = n / 10;
            sum += d * d;
        }
        return sum;
    }
};
```