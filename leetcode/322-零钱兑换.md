# 322. 零钱兑换

> [题目链接](https://leetcode.cn/problems/coin-change/?envType=study-plan-v2&envId=top-interview-150)

一些注意事项：
- 一般情况, 处理返回最少的硬币数目。
- 特殊情况1, amount = 0, return 0。
- 特殊情况2, 无法组合, return -1。

## 动态规划
时间复杂度o(Sn), S为总金额数, n为coins.size(), 空间复杂度o(S)。
```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // coins=[1, 2, 5], amout = 4
        // F(0) = 0, 当i < 0, F(i)忽略不计.
        // F(1) = min{F(1-1), F(1-2), F(1-5)} + 1 = 1
        // F(2) = min{F(2-1), F(2-2), F(2-5)} + 1 = 1
        // F(3) = min{F(3-1), F(3-2), F(3-5)} + 1 = 2
        // F(4) = min{F(4-1), F(4-2), F(4-5)} + 1 = 2
        // F(i - j)表示 amount = i 用 amount' = i - j + j来表示
        // 赋值amount + 1, 处理  没有任何一种硬币组合能组成总金额的情况
        vector<int> dp(amount + 1, amount + 1);
        dp[0] = 0; // 表示F(0)
        // 依次求解dp[1]、...、dp[amount]
        for (int i = 1; i <= amount; ++i) {
            // 循环来求解 min{......}->dp[i]
            for (int j = 0; j < coins.size(); ++j) {
                if (coins[j] <= i) {
                    // 如F(3-1)正常处理
                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);
                } else {
                    // 如F(3-5)不处理即可
                }
            }
        }
        return dp[amount] == amount ? -1 : dp[amount];
    }
};
```