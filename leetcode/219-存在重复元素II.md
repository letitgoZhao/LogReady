# 219. 存在重复元素II

> [LeetCode题目链接](https://leetcode.cn/problems/contains-duplicate-ii/?envType=study-plan-v2&envId=top-interview-150)

## 初次尝试——unordered_map分组
```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        std::unordered_map<int, vector<int>> map;
        for (int index = 0; index < nums.size(); ++index) {
            // o(n)遍历, 维护map, key - 不重复的数值, value - vector(索引下标),
            // 进行分组
            map[nums[index]].push_back(index);
        }
        // 遍历map
        for (auto it = map.begin(); it != map.end(); ++it) {
            if (it->second.size() == 1)
                continue;
            else {
                std::sort(it->second.begin(), it->second.end());
                if (min_abs(it->second) <= k)
                    return true;
            }
        }
        return false;
    }

private:
    int min_abs(vector<int>& v_sort){
        int min_abs = 100000;
        for (int i = 0; i < v_sort.size(); ++i) {
            for (int j = i + 1; j < v_sort.size(); ++j) {
                if (v_sort[j] - v_sort[i] < min_abs)
                    min_abs = v_sort[j] - v_sort[i]; 
            }
        }
        return min_abs;
    }
};
```


## unordered_map、优化算法可以使用哈希表记录每个元素的最大下标。从左到右遍历数组 nums，当遍历到下标 i 时，进行如下操作：

>如果哈希表中已经存在和 nums[i] 相等的元素且该元素在哈希表中记录的下标 j 满足 i−j≤k，返回 true；
>将 nums[i] 和下标 i 存入哈希表，此时 i 是 nums[i] 的最大下标。
> 上述两步操作的顺序不能改变，因为当遍历到下标 i 时，只能在下标 i 之前的元素中寻找与当前元素相等的元素及该元素的最大下标。
> 当遍历结束时，如果没有遇到两个相等元素的下标差的绝对值不超过 k，返回 false。

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        // 关于哈希表结构的说明:
        // 1. key - nums-value, 保证元素不重复
        // 2. value - 更新map[key]的当前最大下标
        std::unordered_map<int, int> map;
        int len = nums.size();
        for (int i = 0; i < len; ++i) {
            int num = nums[i];
            // 如果在哈希表中找到了num元素, 并用该元素上次的索引（哈希表内容）求绝对值
            // 当绝对值小于等于k时, 此时已经可以判断了, 因为该abs值已经最小了
            if ((map.find(num) != map.end()) && (i - map[num] <= k))
                return true;
            //if (map.count(num) && (i - map[num] <= k))
            //    return true;    
            // 遍历更新、维护哈希表
            map[num] = i;
        }
        return false;
    }
};
```

## 滑动窗口解决方案
**考虑数组 nums 中的每个长度不超过 k+1 的滑动窗口，同一个滑动窗口中的任意两个下标差的绝对值不超过 k。** 
> 如果存在一个滑动窗口，其中有重复元素，则存在两个不同的下标    i 和 j 满足 nums[i]=nums[j] 且 ∣i−j∣≤k。

如果所有滑动窗口中都没有重复元素，则不存在符合要求的下标。因此，只要遍历每个滑动窗口，判断滑动窗口中是否有重复元素即可。

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        // 滑动窗口的范围为[max(i - k), i]
        // 1. 当i > k时, 则i - k - 1的元素移出滑动窗口, 即set移除元素
        // 2. 判断nums[i]是否在哈希集合中
        // 如果nums[i]在集合中, 一定满足题意, 直接返回true
        // 3. 默认遍历时增加哈希元素, if-condition删除元素
        unordered_set<int> set;
        int len = nums.size();

        for (int i = 0; i < len; ++i) {
            if (i > k)
                set.erase(nums[i - k - 1]);
            if (set.count(nums[i]))
                return true;

            set.emplace(nums[i]);
        }
        // 遍历结束哈希集合中均找不到相同元素
        return false;
    }
};
```