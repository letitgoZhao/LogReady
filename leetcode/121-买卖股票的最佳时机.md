# 121. 买卖股票的最佳时机

> [题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/?envType=study-plan-v2&envId=top-interview-150)

## 初次尝试——超时限制

采用类似选择排序思想——超时1。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int size = prices.size();
        // 收益默认为0, 因为负收益和零收益均要输出0
        int maxProfit = 0;
        for (int i = 0; i < size; ++i) {
            for (int j = i + 1; j < size; ++j) {
                if (prices[j] - prices[i] > maxProfit) {
                    maxProfit = prices[j] - prices[i];
                }
            }
        }
        return maxProfit;
    }
};
```

采用排序算法优化——超时2。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int maxProfit = 0, max = 0;

        for (int i = 0; i < prices.size() - 1; ++i) {
            vector<int> copy = prices;
            // 对i后元素排序
            sort(copy.begin() + i + 1, copy.end());
            max = copy[prices.size() - 1] - prices[i];
            if (max > maxProfit) 
                maxProfit = max;
        }
        return maxProfit;
    }
};
```

## 一次遍历

该算法的思想是：每次遍历到的元素和该元素`之前的最小值`做差来求得该时刻抛出所赚得到的最大收益。每迭代一次就要更新`最小值`（是否存在），这点和股市很相似。和股市类似，每迭代一次就要更新最大收益，以方便知道当前最大收益。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int inf = 1e9;
        int min_price = inf, maxProfit = 0;
        for (const auto p : prices) {
            // 记录最大利润
            maxProfit = max(maxProfit, p - min_price);
            // 记录最小
            min_price = min(p, min_price);
        }
        return maxProfit;
    }
};
```