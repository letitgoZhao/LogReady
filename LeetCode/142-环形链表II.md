# 142. 环形链表II

> [题目链接](https://leetcode.cn/problems/linked-list-cycle-ii/)

给定一个链表的头节点 `head`, 返回链表开始入环的第一个节点。 如果链表无环, 则返回`null`。


## 解题思路

弗洛伊德的龟兔算法(快慢指针方法)可以用来监测`链表是否存在环`, 并可以用来监测`环的入口`。

- 需要注意的是, 快慢指针相遇的位置不一定是环的入口, 相遇仅能够确定链表中存在环。
- 为了能够找到环, 考虑引入一个新的指针`ptr`, 辅助帮忙找到位置。
- 假设链表中存在一个环, 且环的入口是节点`A`, 环的起点到环的入口位置的距离是`d`, 环的长度是`k`。假设快慢指针已经相遇, 则此时慢指针已经走过的距离是`d+mk(m表示慢指针走过的圈数, m=0,1,2,...)`, 快指针走过的距离是`d+nk(n表示快指针走过的圈数, n=0,1,2,...)`, 因而两者相差的距离长度是圈的整数倍数。
- 如何得到环入口位置呢? 假设`ptr`指针从链表的头节点位置出发, 并让其与`slow`节点一起出发, 此时`ptr`走过的距离是`x`, 而`slow`走过的距离是`x+d+mk`, 相当于两者相差的距离是`d+(m-1)k`, 即两者相遇的位置就是环的入口位置了!



```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Step 1: 快慢指针初始化
        slow, fast = head, head
        # Step 2: 检测是否有环
        while fast and fast.next:
            slow = slow.next        # 慢指针每次移动1步
            fast = fast.next.next   # 快指针每次移动2步
            if slow == fast:
                # Step 3: 找到相遇点，找环的入口
                ptr = head
                while ptr != slow:
                    ptr = ptr.next
                    slow = slow.next
                return ptr
        # 如果没有环，返回 None
        return None
```