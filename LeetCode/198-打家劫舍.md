# 198. 打家劫舍

> [题目链接](https://leetcode.cn/problems/house-robber/?envType=study-plan-v2&envId=top-interview-150)


## 动态规划

时间复杂度`o(n)`、空间复杂度`o(n)`。
```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        // dp[i]表示前i间房屋能偷窃到的最高金额
        // 状态转移方程:
        // dp[i] = max{ dp[i - 2] + nums[i], dp[i - 1] };
        // 边界条件:
        // dp[0] = nums[0], dp[1] = max{ nums[0], nums[1] };
        if (nums.size() == 1)
            return nums[0];
        // 最少两个元素的情况, vector记录状态
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); ++i) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[nums.size() - 1];
    }
};
```

使用滚动数组进行空间复杂度的优化。
```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        // dp[i]表示前i间房屋能偷窃到的最高金额
        // 状态转移方程:
        // dp[i] = max{ dp[i - 2] + nums[i], dp[i - 1] };
        // 边界条件:
        // dp[0] = nums[0], dp[1] = max{ nums[0], nums[1] };
        if (nums.size() == 1)
            return nums[0];
        // 最少两个元素的情况, vector记录状态
        vector<int> dp(nums.size(), 0);
        int dp0 = nums[0];
        int dp1 = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); ++i) {
            int temp = dp1;
            dp1 = max(dp0 + nums[i], dp1);
            dp0 = temp;
        }
        return dp1;
    }
};
```