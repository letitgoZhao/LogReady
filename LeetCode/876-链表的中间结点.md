# 876. 链表的中间结点

> [题目链接](https://leetcode.cn/problems/middle-of-the-linked-list/description/)


给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。如果有两个中间结点，则返回第`二个中间结点`。

示例输入: `head=[1,2,3,4,5]`, 输出: `[3,4,5]`; `head=[1,2,3,4,5,6]`, 输出: `[4,5,6]`。

## 解题思路

使用快慢指针，快指针每次移动两步，慢指针每次移动一步，当快指针到达链表末尾时，慢指针正好到达链表的中间位置。

**初次尝试, 先给出链表的长度, 然后根据这个链表长度的奇偶性质分别进行操作。**

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        if (head == nullptr || head->next == nullptr)
            return head;
        ListNode* low = head;
        ListNode* temp = head;
        int len = 0;
        // 统计链表的长度
        while (temp != nullptr) {
            len++;
            temp = temp->next;
        }
        // 根据示例的 `输入-输出`规律, 分类总结
        if (len % 2 == 0) {
            ListNode* fast = head->next;
            while (fast != nullptr && fast->next != nullptr) {
                // 快慢指针更新
                low = low->next;
                fast = fast->next->next;
            }
            return low->next;
        }
        else {
            ListNode* fast = head;
            while (fast != nullptr && fast->next != nullptr) {
                // 快慢指针更新
                low = low->next;
                fast = fast->next->next;
            }
            return low;
        }
    }
};
```

**性能优化后的版本, 主要处理奇偶长度的情况, 性能提升, 逻辑一致。**

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        if (head == nullptr || head->next == nullptr)
            return head;
        ListNode* low = head;
        ListNode* hig = head;
        while (hig != nullptr && hig->next != nullptr) {
            low = low->next;
            hig = hig->next;
            if (hig != nullptr) {
                hig = hig->next;
            }
        }
        return low;
    }
};
```

**对应的python代码如下所示。**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        low, high = head, head
        while (high is not None and high.next is not None):
            low = low.next
            high = high.next
            if high.next is not None:
                high = high.next
        return low
```