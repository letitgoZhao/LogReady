# 167. 两数之和II-输入有序数组

> [题目链接](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/?envType=study-plan-v2&envId=top-interview-150)

## 暴力匹配o(N^2)——超出时间限制
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int> ans;
        for (int p1 = 0; p1 < numbers.size(); p1++) {
            for (int p2 = p1 + 1; p2 < numbers.size(); p2++) {
                if ( numbers[p1] + numbers[p2] == target ) {
                    ans.push_back(p1 + 1);
                    ans.push_back(p2 + 1);
                    return ans;
                }
            }
        }
        return ans;
    }
};
```

## 优化暴力匹配——内循环优化
原来的算法内循环时间复杂度为o(n)，优化为o(lgn)，采用二分匹配算法。
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left, mid, right;
        for (int p1 = 0; p1 < numbers.size(); p1++) {
            left = p1 + 1, right = numbers.size() - 1;
            // 二分算法优化, 查询是否能找到target - numbers[p1]
            while (left <= right) {
                mid = (left + right) / 2;
                if (numbers[mid] == target - numbers[p1])
                    return {p1 + 1, mid + 1};
                else
                    (numbers[mid] > target - numbers[p1]) ? (right = mid - 1)
                                                          : (left = mid + 1);
            }
        }
        return {-1, -1};
    }
};
```


## 利用题目性质优化双下标

初始时两个指针分别指向一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        /* 利用题目的性质来筛选优化 升序排列 -> 优化筛选的范围 */
        // numbers[left] + numbers[right] == target, 说明刚好得到结果
        // numbers[left] + numbers[right] <  target, 说明numbers[left] + numbers[mid] < target, l++
        // numbers[left] + numbers[right] >  target, 说明numbers[mid]  + numbers[right] > target, r--
        int left = 0, right = numbers.size() - 1, sum = 0;
        while (left < right) {
            sum = numbers[left] + numbers[right];
            if (sum == target) {
                return {left + 1, right + 1};
            }
            if (sum < target) {
                left++;
            }
            if (sum > target) {
                right--;
            }
        }
        // 检测不到返回指定默认值
        return {-1, -1};
    }
};
```