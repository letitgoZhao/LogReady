# 100. 相同的树

> [题目链接](https://leetcode.cn/problems/same-tree/description/?envType=study-plan-v2&envId=top-interview-150)

给你两棵二叉树的根节点`p`和`q`，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。要求: 两棵树上的节点数目都在范围`[0, 100]`内, 且`-104 <= Node.val <= 104`。

**方案1: 基于递归的深度优先搜索。**

- 如果两个树的根节点都为None，说明这两个树是相同的（因为它们都是空树）。
- 如果一个树的根节点为None而另一个不为None，说明这两棵树不同。如果两个树的根节点的值不同，那么它们也不同。
- 递归比较: 如果当前节点的值相同，则递归比较左右子树。只有当左右子树都相同时，两个树才能被认为是相同的。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if (p is None and q is None):
            return True
        if (p is None and q is not None) or (p is not None and q is None):
            return False
        if p.val == q.val:
            left_sub: bool = self.isSameTree(
                p.left, q.left
            )
            right_sub: bool = self.isSameTree(
                p.right, q.right
            )
        else:
            return False
        return left_sub and right_sub
```

**方案2: 方案2：广度优先搜索 (BFS)。**

- 使用队列遍历：使用队列对两棵树进行层级遍历。分别将p和q的节点加入队列，逐层对比节点的值和结构。
- 逐层对比：
  - 对每一层，检查当前节点是否同时为空或同时非空，并且节点值是否相同。如果当前节点值相同，继续将左右子树加入队列。
  - 如果发现任何节点不符合上述条件，直接返回False。
- 结束条件：如果队列为空且没有发现不相等的情况，说明树是相同的。

```python
from collections import deque
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        # 使用队列进行层级遍历
        queue_p = deque([p])
        queue_q = deque([q])
        
        while queue_p and queue_q:
            node_p = queue_p.popleft()
            node_q = queue_q.popleft()
            
            # 如果两个节点都为空，继续检查下一对
            if not node_p and not node_q:
                continue
            
            # 如果一个为空，另一个不为空，或者值不同，返回False
            if not node_p or not node_q or node_p.val != node_q.val:
                return False
            
            # 将左右子节点加入队列
            queue_p.append(node_p.left)
            queue_p.append(node_p.right)
            queue_q.append(node_q.left)
            queue_q.append(node_q.right)
        
        # 如果队列都为空，说明所有节点都比较过，且没有问题，返回True
        return not queue_p and not queue_q
```