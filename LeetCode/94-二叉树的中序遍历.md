# 94. 二叉树的中序遍历

> [题目链接](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

**题目要求:**

给定一个二叉树的根节点`root`，返回 它的`中序遍历`。树中节点数目在范围`[0, 100]`内, 且`-100 <= Node.val <= 100`。

```txt
输入数据: root = [1,null,2,3]。
输出数据: [1,3,2]。
```

**解题方案:** 中序位置的代码是左子树遍历完成后, 还没执行右子树时执行的。

递归遍历方式:

```python
class Solution:
    def dfs(self, root: Optional[TreeNode], res: List[int]) -> None:
        if root is None:
            return
        self.dfs(root.left, res)
        # 中序递归遍历的位置 -> 操作
        res.append(root.val)
        self.dfs(root.right, res)

    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res_list: List[int] = []
        # 深度优先搜索
        self.dfs(root, res_list)
        return res_list
```

迭代遍历方式(`一路向左压栈, 直至到达最左节点, 弹出节点并访问, 然后转向右子树继续当前的过程`):

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res: List[int] = []    # 保存结果
        stack: List[TreeNode] = []  # 栈结构模拟递归过程
        cur = root

        while cur or stack:
            # 将左子树压入栈中
            while cur:
                stack.append(cur)
                cur = cur.left

            # 中序遍历, 访问当前节点
            node = stack.pop()
            res.append(node.val)
            
            # 转向右子树
            cur = node.right  # 这里应该直接将右子树赋给 cur

        return res
```