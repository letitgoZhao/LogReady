# 101. 对称二叉树

> [题目链接](https://leetcode.cn/problems/symmetric-tree/description/?envType=study-plan-v2&envId=top-interview-150)

给你一个二叉树的根节点 `root`, 检查它是否轴对称。要求: 树中节点数目在范围`[1, 1000]`内, 且有`-100 <= Node.val <= 100`。

```txt
输入：root = [1,2,2,null,3,null,3]
输出：false
```

**方案1: 广度优先搜索。**

- 初始化队列：将根节点root放入队列中。
- 层级遍历：使用一个while循环逐层处理树的节点。每次从队列中取出当前层的节点，保存当前层的节点值（用None代表空节点）。
- 对称性检查：对于每一层，判断该层节点值的顺序是否对称。通过将该层的节点值倒序，检查倒序后是否与原顺序相等。
- 继续遍历：如果对称，继续处理下一层的节点。否则返回False。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        # 广度优先搜索BFS方法, 将层级node节点元素找出, 判断层级node节点元素是否对称即可 (root一定不是None)
        q: deque = deque()
        q.append(root)

        while q:
            # 层级list以及迭代次数控制
            level_ls: List[int] = []
            level_sz: int = len(q)
            for i in range(level_sz):
                node = q.popleft()
                # 区别元素 -200, 原题目要求: -100 <= node.val <= +100
                if node is None:    level_ls.append(-200)
                else:               level_ls.append(node.val)
                # 可以控制最后迭代的停止, 最后情况None -> q 为empty
                if node is not None: 
                    q.append(node.left)
                    q.append(node.right)
            # 链表元素的翻转来判断对称结构是否成立
            reverse_ls = level_ls[::-1]
            if not reverse_ls == level_ls:
                return False
        return True
```

**方案2：基于递归的深度优先搜索方法。**

- 递归函数：递归判断两个子树是否对称。如果两棵子树是对称的，要求它们的根节点值相等，且左子树的左子树与右子树的右子树对称，左子树的右子树与右子树的左子树对称。
- 基准条件：当两个节点都为空时，说明对称；当其中一个为空而另一个不为空时，不对称；当两个节点的值不相等时，也不对称。
- 递归调用：递归检查左子树与右子树之间的对称性。

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        # 辅助函数：判断两棵树是否对称
        def isMirror(t1, t2):
            if not t1 and not t2:
                return True
            if not t1 or not t2:
                return False
            return (t1.val == t2.val) and isMirror(t1.left, t2.right) and isMirror(t1.right, t2.left)

        if not root:
            return True  # 空树是对称的
        return isMirror(root.left, root.right)
```