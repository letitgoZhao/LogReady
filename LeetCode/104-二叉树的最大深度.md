# 104. 二叉树的最大深度

> [题目链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150)

**题目要求:**

给定一个二叉树 `root`，返回其最大深度。

二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。
注意: 树中节点的数量在 `[0, 104]` 区间内， 且满足`-100 <= Node.val <= 100`。

```txt
输入数据: root = [3,9,20,null,null,15,7]
输出输出: 3
```

**深度优先搜索DFS方案:**

初步编写方案, 需要使用类中的属性, 所以采用类方法, 递归遍历二叉树, 每次递归时, 节点深度加1, 当遍历到叶子节点时, 更新最大深度, 最后返回最大深度.

```python 
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        # 记录最大深度
        self.max_depth = -float('inf')
        # 记录当前节点的深度
        self.cur_depth = 0

    def _traverse(self, node: Optional[TreeNode]) -> None:
        # 采用深度优先搜索方法 DFS
        if node is None:
            return
        # 前序操作, 节点深度加1
        self.cur_depth += 1
        if node.left is None and node.right is None:
            self.max_depth = max(self.max_depth, self.cur_depth)
        # 向左递归
        self._traverse(node.left)
        # 向右递归
        self._traverse(node.right)
        # 递归返回上一个节点
        self.cur_depth -= 1

    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        else:
            # 更新数据
            self._traverse(root)
            return self.max_depth

```

优化方案, 不需要使用类中的属性, 所以采用类方法, 递归遍历二叉树, 每次递归时, 节点深度加1, 当遍历到叶子节点时, 更新最大深度, 最后返回最大深度.

```python
class Solution:
    def _traverse(self, node: Optional[TreeNode], cur_depth: int, max_depth: int) -> int:
        # 采用深度优先搜索方法 DFS
        if node is None:
            return max_depth
        # 前序操作, 节点深度加1
        cur_depth += 1
        # 叶子节点的深度判断
        if node.left is None and node.right is None:
            max_depth = max(max_depth, cur_depth)
        # 向左递归
        max_depth = self._traverse(node.left, cur_depth, max_depth)
        # 向右递归
        max_depth = self._traverse(node.right, cur_depth, max_depth)
        # 每次递归时 `cur_depth` 是局部变量，递归返回后自动恢复，不需要手动减 1
        # cur_depth -= 1 -> 利用栈特性/递归调用特性, 自动传递
        
        return max_depth

    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        else:
            # 从根节点开始调用递归，初始深度为0
            return self._traverse(root, 0, 0)
```

更简单的递归方案。

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        # 如果节点为空，返回0
        if root is None:
            return 0
        # 如果是叶子节点，深度为1
        if root.left is None and root.right is None:
            return 1
        # 递归计算左子树和右子树的最大深度
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        # 返回左、右子树深度中的较大值，加上当前节点
        return max(left_depth, right_depth) + 1
```

**广度优先搜索BFS方案:**

在 BFS 中，通过逐层遍历每个节点，最后一层就是叶子节点。而不需要叶子节点的判断环节, 只需要记录当前层的节点数量, 每次遍历完一层, 节点深度加1, 最后返回最大深度.
这是因为, 二叉树的最后一层一定是叶子节点, 所以不需要判断叶子节点, 直接返回最大深度即可。

```python 
from collections import deque

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0  # 如果树为空，深度为0
        
        # 初始化队列，开始广度优先遍历
        q = deque([root])
        max_depth = 0

        while q:
            level_sz = len(q)  # 当前层的节点数量
            max_depth += 1  # 每处理一层，深度加1
            for _ in range(level_sz):
                node = q.popleft()  # 出队列一个节点
                # 叶子节点检查：如果没有左右子节点，即为叶子节点
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)

        return max_depth
```