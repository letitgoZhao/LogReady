# 145. 二叉树的后序遍历

> [题目链接](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

**题目要求:**

给你一棵二叉树的根节点`root` ，返回其节点值的`后序遍历`。树中节点的数目在范围`[0, 100]`内, 且 `-100 <= Node.val <= 100`。


**方案实现:** 后序位置的代码是左右字数均遍历完成后, 即离开节点时执行的。

递归遍历方式:

```python
class Solution:
    def dfs(self, node: Optional[TreeNode], res: List[int]) -> None:
        if node is None:
            return
        self.dfs(node.left, res)
        self.dfs(node.right, res)
        # 后序遍历位置 -> 操作
        res.append(node.val)
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res: List[int] = []
        self.dfs(root, res)
        return res
```

迭代遍历方式(`利用反向前序遍历(根->右->左), 然后通过反转结果来得到后序结果`):

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res: List[int] = []   # 保存结构
        stack: List[int] = [] # 栈结构模拟递归过程
        
        if root is not None:
            stack.append(root)# 将root节点压入栈中

        while len(stack) != 0:
            node = stack.pop()              # 返回list[-1], 栈结构特性
            res.append(node.val)

            if node.left is not None:
                stack.append(node.left)     # 先左子树
            if node.right is not None:
                stack.append(node.right)    # 再右子树 (根->右->左)
        return res[::-1]
```