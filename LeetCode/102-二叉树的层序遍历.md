# 102. 二叉树的层次遍历

> [题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-interview-150)

给你二叉树的根节点`root`，返回其节点值的`层序遍历`(即逐层地，从左到右访问所有节点)。注意: 树中节点数目在范围`[0, 2000]` 内, `-1000 <= Node.val <= 1000`。 

```txt
输入数据: root = [3,9,20,null,null,15,7]
输出数据: [[3],[9,20],[15,7]]
```
**解决方案如下所示:**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from typing import Optional, List
from collections import deque
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res: List[List[int]] = []
        if root is None:
            return res
        # 初始化根root节点
        q = deque()
        q.append(root)
        # 层次遍历, 并添加元素顺序
        # 每层的元素个数为[1, 2, 4, 8, ...], 而二叉树每个node只能向下遍历左、右子树, 因而需要控制/记录每层节点个数的代码
        while q:
            layer: List[int] = []   # 存储每层的元素
            level_num: int = len(q) # 表示该层的节点个数
            for _ in range(level_num):
                # 依次出队列, 从左至右, 并依次填充数据
                node = q.popleft()
                layer.append(node.val)
                
                # 分别存储当前node的下一层的节点数据
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            # 每一层依次序链接 -> list[]
            res.append(layer)
        return res
```