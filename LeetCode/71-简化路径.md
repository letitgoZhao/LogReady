# 71. 简化路径

> [题目链接](https://leetcode.cn/problems/simplify-path/description/?envType=study-plan-v2&envId=top-interview-150)

Unix风格的文件系统：
- .     表示当前目录本身。
- ..    表示将目录切换到上一级。
- .或.. 可以存在在复杂目录中。

此题中的注意事项：
- 连续的多个////被视为单个/。
- 任何其他形式的.(.和..除外)被视作 `文件/目录` 的名称。
- 规则的简化文件路径格式：
  1. 始终以/开头, 最后一个目录名(存在)不能以/结尾。
  2. 两个目录之间只有一个/。
  3. 路径不包含.或..。

一些示例说明：
> 输入：path = "/.../a/../b/c/../d/./"
>
> 输出："/.../b/d"
> 
> 解释：
> 
> "..." 是此问题中目录的有效名称。

## deque解决方案（stack也可以）

```cpp
class Solution {
public:
    string simplifyPath(string path) {
        // path 是一个有效的 Unix 风格绝对路径
        // path 由英文字母，数字，'.'，'/' 或 '_' 组成
        std::deque<string> st;
        int i = 0, n = path.size();

        while (i < n) {
            // 处理多个连续的/
            if (i < n && path[i] == '/')
                i++;
            else {
                // 1. 先得到/与/之间的目录名
                string temp = "";
                while (i < n && path[i] != '/')
                    temp += path[i++];
                // 2. 根据目录名进行分支处理
                // 2.1 目录名=..时, 回退（存在合法的目录名）
                // 2.2 目录名=.时, 不操作
                // 2.3 目录名一般情况下(.....或home这样的例子), 记录
                if (temp == ".." && !st.empty())
                    st.pop_back();
                else if (temp != ".." && temp != ".")
                    st.push_back(temp);
            }
        }

        string ans = "/";
        bool flag = false;
        while (!st.empty()) {
            flag = true;
            // 从前往后依次拿出 有效的简化目录名
            ans += st.front() + "/";
            st.pop_front();
        }
        // 处理尾巴/
        if (flag)
            ans.pop_back();
        return ans;
    }
};
```