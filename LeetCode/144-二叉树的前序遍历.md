# 144. 二叉树的前序遍历

> [题目链接](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

**题目要求:**

给你二叉树的根节点`root`，返回它节点值的 `前序遍历`。树中节点数目在范围`[0, 100]`内, 且`-100 <= Node.val <= 100`。

**实现思路:** 前序位置的代码就是刚进入节点时的代码, 或者说`root`指针在树上移动的顺序。

递归遍历方式:

```python
class Solution:
    def dfs(self, node: Optional[TreeNode], res: List[int]) -> None:
        if node is None:
            return
        # 前序遍历的位置 -> 操作
        res.append(node.val)
        self.dfs(node.left, res)
        self.dfs(node.right, res)

    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res: List[int] = []

        self.dfs(root, res)
        return res
```

迭代遍历方式(采用栈结构来模拟`递归结构`, `先访问根节点, 再将右子树、左子树依次压入栈结构, 确保左子树优先被访问`):

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res: List[int] = []   # 保存结构
        stack: List[int] = [] # 栈结构模拟递归过程
        
        if root is not None:
            stack.append(root)# 将root节点压入栈中
        
        while len(stack) != 0:
            # 前序遍历的操作, pop出当前节点, 并append结果数值
            node = stack.pop()              # 返回list[-1], 栈结构特性
            res.append(node.val)

            if node.right is not None:
                stack.append(node.right)    # 先右子树, 保存节点
            if node.left is not None:
                stack.append(node.left)     # 向左递归
        return res
```


