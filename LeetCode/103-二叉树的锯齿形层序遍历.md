# 103. 二叉树的锯齿形层序遍历

> [题目链接](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/)

给你二叉树的根节点`root`, 返回其节点值的`锯齿形层序遍历`。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。其中, 树中节点数目在范围 `[0, 2000]`内, 且`-100 <= Node.val <= 100`。


```txt
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

**解决方案: 基于队列结构的广度优先搜索（通过队列进行广度优先遍历，每层的节点值根据层数奇偶性决定是否反转顺序，最终返回包含每层节点值的二维列表）。**

- 初始化：使用队列q存储当前层的节点，ans_ls记录最终结果，cur_depth表示当前层数。
- 遍历：通过while循环处理每一层的节点，遍历完一层后将节点的左右子树加入队列。
- 对每一层节点值进行处理：如果是偶数层，反转节点值顺序。
- 结果返回：返回包含所有层次的锯齿形遍历结果ans_ls。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        q = deque()
        q.append(root)
        ans_ls: List[List[int]] = []
        cur_depth: int = 0

        while q:
            cur_depth += 1
            level_sz: int = len(q)
            level_ls: List[int] = []

            for i in range(level_sz):
                # 依次出队列
                node = q.popleft()
                # 依次添加节点node数据
                level_ls.append(node.val)
                # 更新下一层的节点node数据
                if node.left is not None:
                    q.append(node.left)
                if node.right is not None:
                    q.append(node.right)
            # 特定specific任务的处理
            if cur_depth % 2 == 0:
                level_ls = level_ls[::-1]
            ans_ls.append(level_ls)
        return ans_ls
```