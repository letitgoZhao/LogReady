# 二叉树核心知识总结

## 二叉树的基础知识

二叉树是一种非常重要且基础的数据结构，它是许多复杂数据结构的基础。理解二叉树对于后续的算法学习和其他数据结构的掌握至关重要。

二叉树是一种树形数据结构，每个节点`最多有两个子节点`。下面是`二叉树结构的一些基本定义`:

- 父节点和子节点: 每个节点的下方直接相连的节点称为子节点，上一层直接相连的节点称为父节点。
- 子树: 以某个节点为根节点的树叫做该节点的子树。
- 根节点和叶子节点: 根节点是树的`最上层节点，没有父节点`; 叶子节点是`最下层的节点，没有子节点`。
- 二叉树的深度: 从`根节点`到`最深的叶子节点`的路径上的`节点数`就是二叉树的`最大深度`。

根据这些概念, 二叉树有不同的类型分类, 下面是一些分类结果:

- 普通二叉树: 每个节点最多有两个子节点，没有特别的限制。
- 满二叉树（Perfect Binary Tree）: 每一层的节点数都是满的，树形呈正三角形。满二叉树的节点个数为`2^n - 1`，其中`n`为树的深度。
- 完全二叉树（Complete Binary Tree）:树的每一层`除了最后一层外，其他层的节点都是满的`，而且最后一层的节点尽可能地集中在左边。特点: `完全二叉树的左右子树也是完全二叉树`。
- 二叉搜索树（Binary Search Tree，BST）: 一种特殊的二叉树，每个节点的左子树所有节点值都比当前节点小，右子树所有节点值都比当前节点大。特点: `子树均满足: 左子树节点值小, 右子树节点值大`, 二叉搜索树可以用于快速查找、插入和删除节点, 可以实现高效的查找操作。
- 高度平衡二叉树（Height-Balanced Binary Tree）: 要求每个节点的左右子树高度差不超过 1，这样可以保持树的高度尽可能地平衡，避免退化为链表。特点: `每个节点的左右子树的高度差不超过１`。
- 自平衡二叉树（Self-Balanced Binary Tree）: 一种可以在增删节点时自动调整结构的树, 最经典的自平衡二叉树是红黑树。特点：使用旋转操作来保持树的平衡，从而保证树的高度始终为``O(log n)`, 提高增删改查的效率。

## 二叉树的前-中-后序遍历

二叉树只有**层序遍历**和**递归遍历**两种结构。
其中, **递归遍历**衍生出了深度优先搜索(DFS)、**广度遍历**衍生出了广度优先搜索(BFS)方法。
二叉树的递归遍历主要分为**前序遍历**、**后续遍历**、**中序遍历**三种方式。它们只是把自定义代码插入到了代码模板的不同位置而已。
二叉树的**递归遍历的模板结构代码**如下所示:

```python
# 基本的二叉树节点
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    # 二叉树的递归遍历框架模板
    def traverse(root: TreeNode):
        if root is None:
            return
        # 前序遍历位置
        traverse(root.left)
        # 中序遍历位置
        traverse(root.right)
        # 后序遍历位置
```

上面这个`traverse`的遍历顺序就是一直往`左子节点`走, 直到遇到空指针不能走了, 才尝试往`右子节点`走; 然后仍然一直尝试往`左子节点`走, 如此循环, 直至`左右子树`都走完了, 则返回上一层的父节点。

简单的拓展, 如果仅仅修改`traverse`函数的递归遍历顺序, 会发生什么呢? 如先递归遍历`root.right`, 然后再递归遍历`root.left`, 会是什么效果呢?

```python
def traverse(root: TreeNode):
    if root is None:
        return
    print('enter', root.val)
    # 前序遍历位置
    traverse(root.left)
    # 中序遍历位置
    traverse(root.right)
    # 后序遍历位置
    print('leave', root.val)
```

可以看到, 该方式也能遍历二叉树的所有节点, 只不过和标准的`traverse`函数的遍历顺序相反。总结的就是, `遍历节点的顺序仅仅取决于左右节点的递归调用的顺序, 与其他的代码是无关的`。

**理解前-中-后序遍历**: 虽然二叉树的顺序递归遍历有模板可供参考, 但是需要理解的是`在不同的位置编写合适的代码, 会得到不同的效果, 这就是前-中-后序遍历的区别`。

**前序遍历方式**: 前序位置的代码就是刚进入节点时的代码, 或者说`root`指针在树上移动的顺序。

递归遍历方式:

```python
class Solution:
    def dfs(self, node: Optional[TreeNode], res: List[int]) -> None:
        if node is None:
            return
        # 前序遍历的位置 -> 操作
        res.append(node.val)
        self.dfs(node.left, res)
        self.dfs(node.right, res)

    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res: List[int] = []

        self.dfs(root, res)
        return res
```

迭代遍历方式(采用栈结构来模拟`递归结构`, `先访问根节点, 再将右子树、左子树依次压入栈结构, 确保左子树优先被访问`):

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res: List[int] = []   # 保存结构
        stack: List[int] = [] # 栈结构模拟递归过程
        
        if root is not None:
            stack.append(root)# 将root节点压入栈中
        
        while len(stack) != 0:
            # 前序遍历的操作, pop出当前节点, 并append结果数值
            node = stack.pop()              # 返回list[-1], 栈结构特性
            res.append(node.val)

            if node.right is not None:
                stack.append(node.right)    # 先右子树, 保存节点
            if node.left is not None:
                stack.append(node.left)     # 向左递归
        return res
```


**中序遍历方式**: 中序位置的代码是左子树遍历完成后, 还没执行右子树时执行的。

递归遍历方式:

```python
class Solution:
    def dfs(self, root: Optional[TreeNode], res: List[int]) -> None:
        if root is None:
            return
        self.dfs(root.left, res)
        # 中序递归遍历的位置 -> 操作
        res.append(root.val)
        self.dfs(root.right, res)

    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res_list: List[int] = []
        # 深度优先搜索
        self.dfs(root, res_list)
        return res_list
```

迭代遍历方式(`一路向左压栈, 直至到达最左节点, 弹出节点并访问, 然后转向右子树继续当前的过程`):

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res: List[int] = []    # 保存结果
        stack: List[TreeNode] = []  # 栈结构模拟递归过程
        cur = root

        while cur or stack:
            # 将左子树压入栈中
            while cur:
                stack.append(cur)
                cur = cur.left

            # 中序遍历, 访问当前节点
            node = stack.pop()
            res.append(node.val)
            
            # 转向右子树
            cur = node.right  # 这里应该直接将右子树赋给 cur

        return res
```

**后序遍历方式**: 后序位置的代码是左右字数均遍历完成后, 即离开节点时执行的。

递归遍历方式:

```python
class Solution:
    def dfs(self, node: Optional[TreeNode], res: List[int]) -> None:
        if node is None:
            return
        self.dfs(node.left, res)
        self.dfs(node.right, res)
        # 后序遍历位置 -> 操作
        res.append(node.val)
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res: List[int] = []
        self.dfs(root, res)
        return res
```

迭代遍历方式(`利用反向前序遍历(根->右->左), 然后通过反转结果来得到后序结果`):

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res: List[int] = []   # 保存结构
        stack: List[int] = [] # 栈结构模拟递归过程
        
        if root is not None:
            stack.append(root)# 将root节点压入栈中

        while len(stack) != 0:
            node = stack.pop()              # 返回list[-1], 栈结构特性
            res.append(node.val)

            if node.left is not None:
                stack.append(node.left)     # 先左子树
            if node.right is not None:
                stack.append(node.right)    # 再右子树 (根->右->左)
        return res[::-1]
```

## 二叉树的层序遍历

上面讲述的递归遍历是依赖函数堆栈递归遍历二叉树的, 遍历顺序是从`最左侧开始`, `一列一列地走到最右侧`。
而二叉树的层次遍历, 就是一层一层的遍历`二叉树`。
层次遍历需要借助队列结构来实现, 根据不同的需求, 可分为`三种写法`。

写法一(`访问值`): 

```python
from collection import deque

def levelOrderTraversal(root):
    if root is None:
        return
    q = deque()
    q.append(root)
    while q:
        cur = q.popleft()
        # 访问 cur 节点
        print(cur.val)

        # 把 cur 的左右子节点加入队列
        if cur.left is not None:
            q.append(cur.left)
        if cur.right is not None:
            q.append(cur.right)
```

写法二(`求树的深度`):

```python
from collection import deque

def levelOrderTraversal(root):
    if root is None:
        return
    q = deque()
    q.append(root)
    # 记录当前遍历到的层数 depth
    depth = 1

    while q:
        # 队列的长度sz一定要在循环前保存, 每次循环过程中队列的长度会更改
        sz = len(q)
        for i in range(sz):
            cur = q.popleft()
            # 访问 cur 节点，同时知道它所在的层数
            print(f"depth = {depth}, val = {cur.val}")

            # 把 cur 的左右子节点加入队列
            if cur.left is not None:
                q.append(cur.left)
            if cur.right is not None:
                q.append(cur.right)
        depth = depth + 1
```

写法三(`加权路径和问题`):

```python
class State(object):
    def __init__(self, node, depth):
        self.node = node
        self.depth = depth

    def levelOrderTraverse(root):
        if root is None:
            return
        q = deque()
        q.append(State(root, 1))

        while q:
            cur = q.popleft()
            # 访问 cur 节点，同时知道它的路径权重和
            print(f"depth = {cur.depth}, val = {cur.node.val}")

            # 把 cur 的左右子节点加入队列
            if cur.node.left is not None:
                q.append(State(cur.node.left, cur.depth + 1))
            if cur.node.right is not None:
                q.append(State(cur.node.right, cur.depth + 1))
```

`LeetCode-102二叉树的层序遍历代码`: 给你二叉树的根节点 `root`, 返回其`节点值`的 `层序遍历（即逐层地，从左到右访问所有节点）`。
如输入数据为 `[root = [3,9,20,null,null,15,7]], 表示二叉树的结构`, 输出数据为 `[[3],[9,20],[15,7]]`。

```txt
     3
    / \
   9  20
      /  \
     15   7

```

实现思路：为了实现层序遍历，我们可以采用广度优先搜索（BFS）的思想，利用队列（queue）来逐层遍历树的节点。

1. 初始化队列：将根节点 root 入队，因为我们从根节点开始遍历。
2. 每一轮遍历时，我们要处理当前队列中所有的节点，换句话说，处理当前层的所有节点。在每次遍历时，首先记录当前队列的长度（即当前层节点的数量）。然后，依次从队列中弹出节点，访问其值，并将其左右子节点（如果有）添加到队列中，准备下一层的遍历。(即依照队列的长度控制当前层的遍历, 并在处理过程中考虑下一层node节点的添加)。
3. 重复步骤 2，直到队列为空，即所有节点都处理完毕。

```python
from typing import Optional, List
from collections import deque
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res: List[List[int]] = []
        if root is None:
            return res
        # 初始化根root节点
        q = deque()
        q.append(root)
        # 层次遍历, 并添加元素顺序
        # 每层的元素个数为[1, 2, 4, 8, ...], 而二叉树每个node只能向下遍历左、右子树, 因而需要控制/记录每层节点个数的代码
        while q:
            layer: List[int] = []   # 存储每层的元素
            level_num: int = len(q) # 表示该层的节点个数
            for _ in range(level_num):
                # 依次出队列, 从左至右, 并依次填充数据
                node = q.popleft()
                layer.append(node.val)
                
                # 分别存储当前node的下一层的节点数据
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            # 每一层依次序链接 -> list[]
            res.append(layer)
        return res
```

## 广度优先搜索(BFS)和深度优先搜索(DFS)初识

在实际的算法问题中, `深度优先搜素DFS`常常用来穷举所有的路径; `广度优先搜素BFS`用来寻找最短路径。
以`LeetCode的111-二叉树的最小深度`例子来说明, 为什么`BFS用来寻找最短路径`?

```txt
问题描述:
给定一个二叉树, 找出其最小的深度。
最小深度指的是从 `根节点` 到 `最近的叶子节点` 的最短路径上的节点数量。

输入: root = [[3], [9, 20], [null, null, 15, 7]]。
输出: 2。

说明: 叶子节点是指没有子节点的节点。
树中节点数的范围在[0, 10^5]内, -1000<=node.val>1000。
```

深度优先搜索(DFS)方法/版本的思路如下所示。
每当遍历到`叶子节点(要进行叶子节点的判断)`时, 就会更新最小深度的值。当`遍历完整棵树`后, 就能计算得到`整棵树的最小深度`。
能不能在不遍历完成整棵树的情况下, `提前结束算法呢`? 不可以, 必须准确的知道每个叶子节点的深度, 才能找到最小的那个值。

```python
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init___(self):
        # 记录最小深度 (根节点到最近的叶子节点的最短路径上的节点数量)
        self.min_depth = float('inf')
        # 记录当前遍历到节点的深度
        self.cur_depth = 0
    
    def _traverse(self, root: Optional[TreeNode]) -> None:
        if root is None:
            return # 递归终止条件

        # 前序位置进入节点时, 增加深度, 作为最小深度的比较指标
        self.cur_depth = self.cur_depth + 1
        
        # 判断当前节点是否是叶子节点, 如果是, 更新所需最小深度
        if root.left is None and root.right is None:
            self.min_depth = min(
                self.mindepth, self.cur_dpth
            )
        # 递归遍历左、右子树
        self._traverse(
            root.left
        )
        self._traverse(
            root.right
        )
        # 后序位置离开节点时, 减少深度, 即cur数值的恢复
        self.cur_depth = self.cur_depth - 1

    def minDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0    # 空树的最小深度为0
        # 从根节点开始进行 DFS 方法
        self._traverse(root)
        return self.min_depth
```

广度优先搜索(BFS方法, `树结构+队列结构的解决思路`)的思路如下所示。

```python
from collections import deque

class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0    # 空树的最小深度为0
        # 初始化队列, 并将根节点加入队列
        q = deque()
        q.append(root)
        # 初始化当前深度, root算一层
        cur_depth = 1

        while q:
            # 获取当前层的节点个数
            level_num = len(q)
            for _ in range(level_num):
                cur_node = q.popleft()
                # 判断当前节点是否是叶子节点
                if cur_node.left is None and cur_node.right is None:
                    # 由于 BFS 按层进行遍历, 因而第一个叶子节点位置的深度就是所求
                    return cur_depth
                # 将下一层节点加入队列
                if cur_node.left is not None:
                    q.append(cur_node.left)
                if cur_node.right is not None:
                    q.append(cur_node.right)
            # 每遍历完一层, 深度加1
            cur_depth += 1
        # 如果遍历完整棵树都没有找到叶子节点, 则返回树的深度
        return cur_depth
```

## 多叉树的前-后序遍历

多叉树结构就是`二叉树结构的延伸与扩展`, 二叉树结构是特殊的多叉树结构。多叉树的遍历就是二叉树结构遍历的扩展。森林指的是`多个多叉树的集合`。

二叉树与多叉树结构的定义与区别如下: 

```python
class BinaryTreeNode:
    def __init__(self, val: int, left: Optional[BinaryTreeNode], right: Optional[BinaryTreeNode]):
        self.val = val
        # 每个节点有 `两个子节点`
        self.left = left
        self.right = right

class MultiTreeNode:
    def __init__(self, val: int, children: List[MultiTreeNode]):
        self.val = val
        # 每个节点有 `任意个子节点`
        self.children = children
```

森林是`多个多叉树的集合(单独一颗多叉树也是一个特殊的森林结构)`, `forest: List[Node] = []`。
森林结构的遍历就是分别对每个多叉树的根节点进行`DFS/BFS`的遍历。
并查集算法中, 会同时持有多叉树的根节点, 并查集的`find`方法就是`DFS`的遍历, `union`方法就是`BFS`的遍历。

多叉树的遍历模板结构如下所示。

```python
def multi_tree_traverse(root: Optional[MultiTreeNode]) -> None:
    if root is None:
        return # 递归终止条件

    # 前序位置 -> 操作位置
    print(root.val)

    # 递归遍历子节点
    for child in root.children:
        multi_tree_traverse(child)

    # 后序位置 -> 操作位置
    print(root.val)
```

LeetCode的`589- N叉树的前序遍历`的代码实现如下所示。

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children
"""
# 给定一个 n叉树的根节点 root, 返回 其节点值的前序遍历。
# n叉树 在输入中按层序进行序列化表示。
# 输入: root = [1,null,3,2,4,null,5,6]
# 输出: [1,3,5,6,2,4]

class Solution:

    def _dfs(self, node: Optional[Node], res: List[int]) -> None:
        if node is None:
            return
        # N叉树的前序遍历 - 插入数据操作
        res.append(node.val)
        for index in range(len(node.children)):
            self._dfs(node.children[index], res)
        
    def preorder(self, root: Optional[Node]) -> List[int]:
        res_list: List[int] = []
        # dfs方法的递归遍历
        self._dfs(
            root, res_list
        )
        return res_list
```

LeetCode的`590- N叉树的后序遍历`的代码实现如下所示。

```python
class Solution:
    def _dfs(self, node: Optional[Node], res: List[int]) -> None:
        if node is None:
            return
        for index in range(len(node.children)):
            self._dfs(node.children[index], res)
        res.append(node.val)

    def postorder(self, root: Optional[Node]) -> List[int]:
        res_list: List[int] = []
        self._dfs(
            root, res_list
        )
        return res_list
```

## 多叉树的层序遍历

`多叉树的层序遍历和二叉树的层序遍历的实现大致是一致的`, 均采用`队列结构实现`, 无非就是把二叉树的左右节点更换为多叉树的所有子节点。

下面先给出`LeetCode-429的N叉树的层序遍历`的实现要求和实现的思路。

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children
"""
from collections import deque

class Solution:
    def levelOrder(self, root: Optional[Node]) -> List[List[int]]:
        # 记录返回结果列表和层次临时列表结构
        res_list: List[List[int]] = []

        if root is None:
            return res_list
        # 采用BFS(补充队列结构), 并初始化队列结构
        q = deque()
        q.append(root)

        while q:
            # 每次都要清空临时列表, 以便后序的挂载
            level_list = []
            # leve_size代表要处理的节点个数
            level_size = len(q)

            for i in range(level_size):
                # 依次出队列来处理节点, 操作 -> append
                node = q.popleft()
                level_list.append(node.val)

                # 分别挂载 子节点 的 孩子节点 children
                if node.children is not None:
                    for i in range(len(node.children)):
                        q.append(node.children[i])

            # 将临时列表挂载到返回结果列表中
            res_list.append(level_list)
        return res_list
```

**多叉树的层序遍历模板1, 适用于无法记录节点深度, 仅遍历结构的:**

```python
from collections import deque

class Solution:
    def level_order_traverse(self, root):
        if root is None:
            return
        
        q = deque()
        q.append(root)

        while q:
            cur = q.popleft()
            # 访问 cur 节点
            print(cur.val)

            # 将 cur 的所有子节点加入队列
            for child in cur.children:
                q.append(child)
```

**多叉树的层序遍历模板2, 适用于能够记录节点深度的版本:**

```python
from collections import deque

class Solution:
    def level_order_traverse(self, root):
        if root is None:
            return
        
        q = deque()
        q.append(root)
        depth = 1

        while q:
            level_size = len(q)
            for i in range(level_size):
                cur = q.popleft()
                print(f'depth = {depth}, cur.val = {cur.val}')
                
                for child in children:
                    q.append(child)
            depth += 1
```

**多叉树的层序遍历模板3, 适配于不同的权变重方法:**

```python
from collections import deque

class State:
    def __init__(self, node, depth):
        self.node = node
        self.depth = depth

class Solution:
    def level_order_traverse(self, root):
        if root is None:
            return
        q = deque()
        # 记录当前遍历的层数, 根节点视作1层
        q.append(
            State(root, 1)
        )
        
        while q:
            state = q.popleft()
            cur = state.node
            depth = state.depth
            print(f"depth = {depth}, val = {cur.val}")
            for child in cur.children:
                q.append(State(child, depth + 1))
```

