# 数字游戏/数字技巧部分的总结

## 数字游戏的引入LeetCode题目

### 292-Nim题目

网址为[https://leetcode.cn/problems/nim-game/description/](https://leetcode.cn/problems/nim-game/description/)。

你和你的朋友，两个人一起玩 Nim 游戏:

- 桌子上有一堆石头。
- 你们轮流进行自己的回合， 你作为先手 。
- 每一回合，轮到的人拿掉 1 - 3 块石头。
- 拿掉最后一块石头的人就是获胜者。

假设你们每一步都是`最优解`。
请编写一个函数, 来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢, 返回 true; 否则, 返回 false。

**我们解决这种问题一般都是反向来思考的:**

如果我能赢, 那么最后轮到我取石子的时候必须要剩下 1~3 颗石子, 这样我才能一把拿完。

如何让我最后取石子的时候剩下 1~3 颗石子呢? 显然地, 如果轮到对手拿的时候还有 4 颗石子, 那么无论他拿走几颗,剩下的都是 1~3 颗, 他总是会输。

如何逼迫对手面对 4 颗石子呢?  让我选的时候还有 5~7 颗石子, 这样无论他拿走几颗,剩下的都是 4 颗。这样我就能赢 (题目限制, 相当于逼迫对方一定是最后沦落到 4 颗石子)。

当 `n=1, 2, 3` 时, 我们可以直接拿走 1~3 颗石子获胜。
当`n=4`时, 无论你拿走几颗石子,对方都可以一次性拿走剩下的石子并获胜。
当 `n=5`时, 我们可以先拿1个, 逼迫对方面临4个石子, 对方输掉后我们获胜。
当 `n=6`时, 我们可以先拿2个, 逼迫对方面临4个石子, 对方输掉后我们获胜。
当 `n=7`时, 我们可以先拿3个, 逼迫对方面临4个石子, 对方输掉后我们获胜。
当 `n=8`时, 我们发现无论我们先拿走几个, 对方都可以一次性拿走剩下的石子并获胜。
底层逻辑就是[1,2,3]->[5,6,7]->[9,10,11]->[13,14,15]...->[4k+1,4k+2,4k+3], 轮到谁开始就能把对方逼迫到绝境, 输掉比赛了。

```cpp
class Solution {
public:
    bool canWinNim(int n) {
        return n % 4 != 0;
    }
}
```

```python
class Solution:
    def canWinNim(self, n: int) -> bool:
        # 如果上来就踩到 4 的倍数，那就认输吧
        # 否则，可以把对方控制在 4 的倍数，必胜
        return n % 4 != 0
```

### 877-石子游戏

网址为[https://leetcode.cn/problems/stone-game/description/](https://leetcode.cn/problems/stone-game/description/)。

Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有正整数颗石子，数目为 piles[i] 。

游戏以谁手中的石子最多来决出胜负。`石子的总数是奇数` ，所以`没有平局`。

Alice 和 Bob 轮流进行，Alice 先开始。每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多的玩家获胜 。

假设 Alice 和 Bob 都`发挥出最佳水平`，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。

提示: 输入`piles = [5,3,4,5`, 返回`true`; 输入`piles = [3,7,2,3]`, 返回`false`。

题解: 这个最关键的是`都发挥出最佳水平`, 因而我们只需要考虑`最优解`即可, 不需要考虑其他情况。每个人只需要采用`max`操作, 确保最优方向, 那么这个问题就是`谁先先手谁就有优势, 取得胜利`。

```cpp
class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        return true;
    }
};
```

```python
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        return True
```

下面主要是分析动态规划的求解思路。
我们定义一个二维数组`dp[i][j]`来表示在子数组`piles[i]`到`piles[j]`之间, 当前玩家所能拿到的石子数目的最大值。
那么`dp[0][n-1]`就是Alice所能拿到的石子数, Alice优先操作。下面是状态转移方程的描述:

当前的玩家可以选择拿走`piles[i]`或者`piles[j]`, 

- 如果拿走`piles[i]`, 剩下的石子为`piles[i+1]`到`piles[j]`, `dp[i+1][j]`表示Bob所能拿到的最优石子数, `total-dp[i+1][j]`就表示Alice剩下能拿到的最优石子数。
- 如果拿走`piles[j]`, 剩下的石子为`piles[i]`到`piles[j-1]`, `dp[i][j-1]`表示Bob所能拿到的最优石子数, `total-dp[i][j-1]`就表示Alice剩下能拿到的最优石子数。
- 于是得到状态转移方程为: Alice在石子堆为`i和j`时, 所能拿到的最优石子数目, `dp[i][j] = max( piles[i] + total[i+1][j] - dp[i+1][j], piles[j] + total[i][j-1] - dp[i][j-1] )`。其中, `dp[i+1][j]`和`dp[i][j-1]`是Bob的最优解, `total[i+1][j]`和`total[i][j-1]`是当前石子堆的总数。
- 目标, 判断`dp[0][n-1]`是否大于`total/2`即可, 因为两者都是最优操作, 仅需判断是否高于一半即可了。

以`piles = [5, 3, 4, 5]`为例, 详细分析具体的执行细节流程。

**第一步: 初始的dp数组如下**。

```txt
dp = [
  [5, 0, 0, 0],
  [0, 3, 0, 0],
  [0, 0, 4, 0],
  [0, 0, 0, 5],
]
```

**第二步: 计算长度为 2 的区间。**

```txt
需要计算 `[0, 1]`, `[1, 2]`, `[2, 3]` 三个子区间。
更新后的dp数组如下所示(仅需更新上三角即可):
dp = [
  [5, 5, 0, 0],
  [0, 3, 4, 0],
  [0, 0, 4, 5],
  [0, 0, 0, 5],
]
```

**后续步骤: 继续迭代计算即可。**

重复此过程，逐步增加区间的长度，最终计算得到`dp[0][n-1]`的值。

注意, 这里说的区间长度, 都是从左侧为[0, 1, 2, ..., len-1]计数, 即对应上三角的位置。

```python
from typing import List

class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        # 石子数长度
        n = len(piles)
        
        # 二维的数组 dp, dp[i][j] 表示在区间 piles[i] 到 piles[j] 中，当前玩家能获得的最大石子数
        dp = [[0] * n for _ in range(n)]

        # 初始化, dp[i][i] 就表示当前的一堆石子数目
        for i in range(n):
            dp[i][i] = piles[i]

        # 求解 total 数组, total[i][j] 表示当前石子堆的总数
        total = [[0] * n for _ in range(n)]
        for i in range(n):
            total[i][i] = piles[i]
            for j in range(i + 1, n):
                total[i][j] = total[i][j - 1] + piles[j]
        
        print("Total array: ")
        print(total)  # 打印 total 数组

        # 求解 dp 数组 (子问题 -> 大问题 -> 全局问题)
        for length in range(2, n+1):
            # length表示 当前子问题的区间长度 length
            for i in range(n - length + 1):
                j = i + length - 1  # 区间范围为[i, j]
                dp[i][j] = max(
                    piles[i] + total[i + 1][j] - dp[i + 1][j],  # 选择从左端拿石子
                    piles[j] + total[i][j - 1] - dp[i][j - 1]   # 选择从右端拿石子
                )
        
        print("DP array: ")
        print(dp)  # 打印 dp 数组

        # 判断 Alice 是否获胜，Alice 获胜条件是 dp[0][n-1] > total[0][n-1] // 2
        return dp[0][n - 1] > total[0][n - 1] // 2

if __name__ == "__main__":
    # 输入石子堆数组: [5, 3, 4, 5]
    piles = list(map(int, input("请输入石子堆数组 (用空格分隔): ").split())) 

    # 创建 Solution 对象
    solution = Solution()

    # 调用 stoneGame 方法并输出结果
    result = solution.stoneGame(piles)
    if result:
        print("Alice 获胜！")
    else:
        print("Bob 获胜！")
```

### 319-灯泡开关

网址为[https://leetcode.cn/problems/bulb-switcher/description/](https://leetcode.cn/problems/bulb-switcher/description/)。


有`n`个灯泡, 最开始的时候灯都是亮着的。现在要进行`n`次操作。

第一轮: 每盏灯全部打开。

第二轮: 按照`2, 4, 6, 8, ....`(每2盏的次序), 按一次开关。

第三轮: 按照`3, 6, 9, ....`(每3盏的次序), 按一次开关。

第四轮: 按照`4, 8, 12, ....`(每4盏的次序), 按一次开关。

......

第n轮: 仅对第n盏灯, 按一次开关即可。

分析, 假设`n = 6`。`[0/1, ....]`表示每个灯的状态。

- 第一轮: `[1, 1, 1, 1, 1, 1]`
- 第二轮: `[1, 0, 1, 0, 1, 0]`, 2, 4, 6操作。
- 第三轮: `[1, 0, 0, 0, 1, 1]`，3, 6操作。
- 第四轮: `[1, 0, 0, 1, 0, 0]`，4操作。
- 第五轮: `[1, 0, 0, 1, 1, 1]`，5操作。
- 第六轮: `[1, 0, 0, 1, 1, 0]`，6操作。

1、一个事实是: 灯始终按照"开-关-开-关"的节奏进行切换。第一次始终是开, 因而切换到奇数次时, 灯亮; 切换到偶数次, 灯灭。

2、第`i`个灯泡会被切换几次? 灯泡`i`在第`j`轮次被切换, 当且仅当`j是i的因数`。

3、平方数的因数个数是奇数个? 因数总是成对存在的。即 $d \times \frac{i}{d} = i$。唯一出现的问题就是: 某一对里两个数其实是同一个数字, 即平方数的情况。

4、总结就是: 只有平方数字的灯泡才会亮着。因而最后就转换为`n`个灯泡(n个数字), 有多少个平方数即可。亮灯的编号是: $1^2, 2^2, 3^2, 4^2, ...$(数字不超过n), 因而这个`最后求解的数字`不能超过$\sqrt{n}$, 最后的数字向下取整即可了。

```python
class Solution:
    def bulbSwitch(self, n: int) -> int:
        return int(n**0.5)
```