# 常用的位操作总结

## 位基础操作

二进制表示, 可以采用`0b`前缀来表示二进制数字。

```cpp
int a = 0b1101;     // 等价于十进制的 13
int b = 0b1010;     // 等价于十进制的 10
```

左移操作`<<`, 将二进制数字向左移动若干位, 右边用`0`补齐, 左移相当于乘以2^n。

右移操作`>>`, 将二进制数字向右移动若干位, 左边用符号位补齐, 右移相当于除以2^n。

负数值等于无符号值减去$2^8$, 即$负数 = 对应的无符号 - 2^8$。

更直观的解释, 以8位数为例, 把8位数想成一个只有0-255的"时钟", 从0往下左5步, 就会到251。

补码设计的原因, 让 "减法边加法" 自然而然地成立, 即 $x + (-x) = 0$天然成立。

两补码的设计把`-x`定义为`2^n - x`(n=8为例)。于是有: $x + (-x) = x + 2^n - x = 0(mod 2^n)$。

与操作、或操作、异或操作。异或操作`^`, 两个对应的二进制位相同时为0, 不同时为1。

异或操作的重要性质: `a ^ a = 0`(任何数和自己异或的结果是 0); `a ^ 0 = a`(任何数和 0 异或的结果是它本身); 异或操作满足结合率。

异或操作的常见应用, 如翻转一个数的某一位, 具体操作为: `n ^ ( 1 << i )`, `1变为0`, `0变为1`。

几个常见的位操作应用还有, 如下所示:

```txt
1. 利用 or 操作 和字符 ' ' 的 ASCII 码, 将一个字符转换为小写字母
('a' | ' ') = 'a'
('A' | ' ') = 'a'

2. 利用 and 操作 和字符 '_', 将一个字符转换为大写字母
('a' & '_') = 'A'
('A' & '_') = 'A'

3. 利用异或操作和字符 ' ', 将一个字符的大小写互换
('a' ^ ' ') = 'A'
('A' & ' ') = 'a'

4. 判断两个数字是否异号。
int x = -1, y = 2;
boolean ans = ((x ^ y) < 0);
```

### 191-位1的个数

网址链接[https://leetcode.cn/problems/number-of-1-bits/description/](https://leetcode.cn/problems/number-of-1-bits/description/)。

给定一个正整数 n，编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中 设置位 的个数（也被称为汉明重量）。

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        # 由于是正整数, 左移、右移均可
        temp = 1
        ans = 0
        while (n != 0):
            if (n & temp):
                ans = ans + 1
            n = n >> 1
        return ans
    
    # 提升运行效率的操作方法
    def hammingWeight_new(self, n: int) -> int:
        ans = 0
        while n:
            # 通过 `n & (n-1)` 清除最低位的 1, 不停的消除1的次数, 迭代次数最多是1的个数
            n = n & (n - 1)
            ans += 1
        return ans
```

### 231-2的幂

网址链接[https://leetcode.cn/problems/power-of-two/description/](https://leetcode.cn/problems/power-of-two/description/)。

给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。

方式1, 凑巧的方式。
```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        ans = 0
        temp = 1
        # 凑巧的方式, -2^31 <= n <= 2^31 - 1
        for _ in range(31):
            if n & temp:
                ans += 1
                if ans > 1:
                    return False
            temp <<= 1
        return ans == 1
```

方式2, 2的幂的性质的应用。

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        # 一定成立
        return (n > 0 ) and ((n & (n - 1)) == 0)
```

方式3, 类似方式1来统计bit的数目。是2的幂次, 则bit位在[1,2,4,8,16,32,64,128]中, 有且仅有1个, 统计是否为1即可了。

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        ans = 0
        while n:
            ans += (n & 1)
            if ans > 1: return False
            n >>= 1
        return ans == 1
```

思考与总结, **当n是2的幂次的时候**, 可能首选的是取模操作, 但是可以选择位操作, 因为位操作效率更高。具体地, 当n是2的幂次的时候, n的二进制表示中只有一位是1, 其余位都是0, 因此n-1的二进制表示中所有位都是1。例如, 8的二进制表示是1000, 8-1的二进制表示是0111。因此, n & (n-1)的结果一定是0。

一个常见的应用是环形数组的使用, 如`arr[index % arr.length]`, 可也以写成`arr[index & (arr.length - 1)]`(index一直自增)。
另一个常见的应用是采用  **x = x & (x - 1)** 的思想来 **消融2的次幂的个数 或者 统计2的次幂的个数**。


### 136-只出现1次的数字

题目链接网址为[https://leetcode.cn/problems/single-number/description/](https://leetcode.cn/problems/single-number/description/)。

给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

常规的字典操作方式如下所示(常规遍历构建字典操作 + 遍历字典找值为1的key): 
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        freq = dict()
        for num in nums:
            if num in freq:
                freq[num] += 1
            else:
                freq[num] = 1
        for k, v in freq.items():
            if v == 1:
                return k
```

异或操作, 考察异或操作的性质: `a ^ a = 0`(任何数和自己异或的结果是 0); `a ^ 0 = a`(任何数和 0 异或的结果是它本身); 异或操作满足结合率。一个数组列表 [num1, num2, num3, ..., num_n], 由于规定了一定满足存在单个不同的num, 其他两两配对, 一定存在`num ^ num = 0`的配对组情况, 可以不同顺序结合, 最后剩下了 `num_single ^ 0 = num ^ single`, 则 `num1 ^ num2 ^ num3 ^ ... ^ num_n = num_single`。

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ans = 0
        for num in nums:
            ans = ans ^ num
        # 满足线性时间复杂度, 常量的额外存储空间算法
        return ans
```

### 268-丢失的数字

题目链接网址为[https://leetcode.cn/problems/missing-number/description/](https://leetcode.cn/problems/missing-number/description/)。


给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。