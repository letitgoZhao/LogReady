# 常用的位操作总结

## 位基础操作

二进制表示, 可以采用`0b`前缀来表示二进制数字。

```cpp
int a = 0b1101;     // 等价于十进制的 13
int b = 0b1010;     // 等价于十进制的 10
```

左移操作`<<`, 将二进制数字向左移动若干位, 右边用`0`补齐, 左移相当于乘以2^n。

右移操作`>>`, 将二进制数字向右移动若干位, 左边用符号位补齐, 右移相当于除以2^n。

负数值等于无符号值减去$2^8$, 即$负数 = 对应的无符号 - 2^8$。

更直观的解释, 以8位数为例, 把8位数想成一个只有0-255的"时钟", 从0往下左5步, 就会到251。

补码设计的原因, 让 "减法边加法" 自然而然地成立, 即 $x + (-x) = 0$天然成立。

两补码的设计把`-x`定义为`2^n - x`(n=8为例)。于是有: $x + (-x) = x + 2^n - x = 0(mod 2^n)$。

与操作、或操作、异或操作。异或操作`^`, 两个对应的二进制位相同时为0, 不同时为1。

异或操作的重要性质: `a ^ a = 0`(任何数和自己异或的结果是 0); `a ^ 0 = a`(任何数和 0 异或的结果是它本身); 异或操作满足结合率。

异或操作的常见应用, 如翻转一个数的某一位, 具体操作为: `n ^ ( 1 << i )`, `1变为0`, `0变为1`。

几个常见的位操作应用还有, 如下所示:

```txt
1. 利用 or 操作 和字符 ' ' 的 ASCII 码, 将一个字符转换为小写字母
('a' | ' ') = 'a'
('A' | ' ') = 'a'

2. 利用 and 操作 和字符 '_', 将一个字符转换为大写字母
('a' & '_') = 'A'
('A' & '_') = 'A'

3. 利用异或操作和字符 ' ', 将一个字符的大小写互换
('a' ^ ' ') = 'A'
('A' & ' ') = 'a'

4. 判断两个数字是否异号。
int x = -1, y = 2;
boolean ans = ((x ^ y) < 0);
```

### 191-位1的个数

网址链接[https://leetcode.cn/problems/number-of-1-bits/description/](https://leetcode.cn/problems/number-of-1-bits/description/)。

给定一个正整数 n，编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中 设置位 的个数（也被称为汉明重量）。

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        # 由于是正整数, 左移、右移均可
        temp = 1
        ans = 0
        while (n != 0):
            if (n & temp):
                ans = ans + 1
            n = n >> 1
        return ans
    
    # 提升运行效率的操作方法
    def hammingWeight_new(self, n: int) -> int:
        ans = 0
        while n:
            # 通过 `n & (n-1)` 清除最低位的 1, 不停的消除1的次数, 迭代次数最多是1的个数
            n = n & (n - 1)
            ans += 1
        return ans
```

### 231-2的幂

网址链接[https://leetcode.cn/problems/power-of-two/description/](https://leetcode.cn/problems/power-of-two/description/)。

给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。

**方式1, 凑巧的方式。**
```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        ans = 0
        temp = 1
        # 凑巧的方式, -2^31 <= n <= 2^31 - 1
        for _ in range(31):
            if n & temp:
                ans += 1
                if ans > 1:
                    return False
            temp <<= 1
        return ans == 1
```

**方式2, 2的幂的性质的应用。**

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        # 一定成立
        return (n > 0 ) and ((n & (n - 1)) == 0)
```

**方式3, 类似方式1来统计bit的数目。**是2的幂次, 则bit位在[1,2,4,8,16,32,64,128]中, 有且仅有1个, 统计是否为1即可了。

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        ans = 0
        while n:
            ans += (n & 1)
            if ans > 1: return False
            n >>= 1
        return ans == 1
```

思考与总结, **当n是2的幂次的时候**, 可能首选的是取模操作, 但是可以选择位操作, 因为位操作效率更高。具体地, 当n是2的幂次的时候, n的二进制表示中只有一位是1, 其余位都是0, 因此n-1的二进制表示中所有位都是1。例如, 8的二进制表示是1000, 8-1的二进制表示是0111。因此, n & (n-1)的结果一定是0。

一个常见的应用是环形数组的使用, 如`arr[index % arr.length]`, 可也以写成`arr[index & (arr.length - 1)]`(index一直自增)。
另一个常见的应用是采用  **x = x & (x - 1)** 的思想来 **消融2的次幂的个数 或者 统计2的次幂的个数**。


### 136-只出现1次的数字

题目链接网址为[https://leetcode.cn/problems/single-number/description/](https://leetcode.cn/problems/single-number/description/)。

给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

常规的字典操作方式如下所示(常规遍历构建字典操作 + 遍历字典找值为1的key): 
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        freq = dict()
        for num in nums:
            if num in freq:
                freq[num] += 1
            else:
                freq[num] = 1
        for k, v in freq.items():
            if v == 1:
                return k
```

异或操作, 考察异或操作的性质: `a ^ a = 0`(任何数和自己异或的结果是 0); `a ^ 0 = a`(任何数和 0 异或的结果是它本身); 异或操作满足结合率。一个数组列表 [num1, num2, num3, ..., num_n], 由于规定了一定满足存在单个不同的num, 其他两两配对, 一定存在`num ^ num = 0`的配对组情况, 可以不同顺序结合, 最后剩下了 `num_single ^ 0 = num ^ single`, 则 `num1 ^ num2 ^ num3 ^ ... ^ num_n = num_single`。

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ans = 0
        for num in nums:
            ans = ans ^ num
        # 满足线性时间复杂度, 常量的额外存储空间算法
        return ans
```

### 268-丢失的数字

题目链接网址为[https://leetcode.cn/problems/missing-number/description/](https://leetcode.cn/problems/missing-number/description/)。


给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。

其中, `n == nums.length`, `1 <= n <= 10^4`, `1<=nums[i]<=n`, `nums`中的所有数字都是`独一无二`的。

示例, 输入为`[3,0,1]`, 输出为`2`。

**思路1: 求和, 然后减去数组中的元素, 得到丢失的数字。**

```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        sum = (0 + n) * (n + 1) // 2 # 一定是整数
        for num in nums:
            sum -= num
        return sum
```

**思路2, 异或操作。**利用异或的性质, 一个数和它本身做异或操作是0, 和0做异或操作还是它本身, 而且异或操作还满足结合律的性质。因而, 思路就是, 补全索引`n`, 然后将索引和数组的所有元素都考虑, 做成一个异或操作, 得到的结果就是丢失的数字, 即`ans = index_0 ^ index_1 ^ ... ^ index_n-1 ^ arr[0] ^ ... ^ arr[n - 1] ^ index_n ^ 0`。

```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        for index, num in enumerate(nums):
            ans = ans ^ (index ^ num)
        return ans ^ n
```

**思路3, 排序操作, 然后遍历一遍就能找到丢失的数字, 但是时间复杂度是O(nlogn), 即排序算法的瓶颈。**`[3,0,1]`, 排序后是`[0,1,3]`, 索引是`[0,1,2]`, 丢失的数是不同是的索引index; 另一种情况就是多余的n。


```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        for index, num in enumerate(nums):
            if index != num:
                return index
        return n
```

**思路4, 使用集合操作, 将数组中的元素添加到集合中, 然后遍历索引, 如果索引不在集合中, 则返回索引, 否则返回n**。时间复杂度是O(n), 空间复杂度是O(n)。


```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        set_number = set(nums)
        for index in range(len(nums) + 1):
            if index not in set_number:
                return index
```

## 一些常见的数学技巧

### 模运算的技巧

- 加法: `(a + b) % k = (a % k + b % k) % k`。
- 减法: `(a - b) % k = (a % k - b % k + k) % k`。加k的目的是防止结果出现负数, 如(1-3)%5, 有的编程语言的结果可能是-2, 数学上是3。
- 乘法: `(a * b) % k = (a % k) * (b % k) % k`。可以证明, `a = p1 * k + r1`, `b = p2 * k + r2`, 则`ab = (p1 * p2 * k + r1 * p2 + r2 * p1 * k + r1 * r2) % k = (r1 * r2) % k`。


### 快速幂的求解

快速幂运用到了幂运算的性质, 按照指数的奇偶性质进行递归计算。每次可以将规模进行减半, 时间复杂度为O(logn)。

$$
a^b = 
\begin{cases} 
\left( a^{\frac{b}{2}} \right)^2, & \text{当 } b \text{ 为偶数} \\
a \cdot a^{b-1}, & \text{当 } b \text{ 为奇数}
\end{cases}
$$

快速幂的计算的参考代码如下所示。

```cpp
#include <iostream>

// 计算 a^b 的快速幂
long quickPow(long a, long b) {
    long res = 1;

    while (b > 0) {
        // 如果 b 是奇数，则乘上当前的 a
        if (b % 2 == 1) {
            res = res * a;
        }
        // 进行底数的平方
        a = a * a;
        // b 右移一位，相当于 b // 2
        b /= 2;
    }

    return res;
}

int main() {
    long a = 2;
    long b = 10;
    long result = quickPow(a, b);
    std::cout << a << "^" << b << " = " << result << std::endl;
    return 0;
}
```

补充, 计算`(a ^ b) % k`的参考代码, 即计算`(a * a * ... * a) % k`的例子。

```cpp
long quickPow(long a, long b, long k)
{
    long res = 1;
    // 预处理, 防止a大于k的情况而引起的计算复杂性升高
    a = a % k;
    while (b > 0) // 采用b来控制的是迭代的次数
    {
        // 采用位运算判断奇偶性质
        if ( (b & 1) == 1 )
        {
            // 计算 a % k, 再赋给 res, 
            res = (res * a) % k;
        }
        // b - 1是偶数了, 折半进行递归的计算
        a = (a * a) % k; // 自下而上, 1 -> 2 -> 4 -> 8 -> 16
        b = b >> 1;
    }
    return res;
}
```

### 最大公约数的求解, Greatest Common Divisor, GCD

最大公约数是指能够同时整除两个或多个整数的最大正整数。即`gcd(a, b) = d`, 则应该有`a % d == 0`, `b & d == 0`, 且不存在比`d`更大的数满足上边的情况。

求解最大公约数的常用方法是**欧几里得算法(Euclidean algorithm)**, 基本思想是, `gcd(a, b) = gcd(b, a % b)`, 其中`a % b`表示a除以b的余数, 直到`b == 0`, 此时`a`就是最大公约数。

```cpp
int gcd(int a, int b)
{
    if (a <  b) { 
        // swap算法
        int temp = a;
        a = b;
        b = temp;
    }

    // 采用递归的方式
    if (b == 0)
    {
        return a;
    }
    return gcd(b, a % b);
}
```

```txt
gcd(48, 18)
= gcd(18， 48 % 18)
= gcd(18, 12)
= gcd(12, 18 % 12)
= gcd(12, 6)
= gcd(12, 6 % 12)
= gcd(12, 0)
= 12， b = 0, 则返回a
```

### 最小公倍数的求解, Least Common Multiple, LCM

最小公倍数是指能够同时被两个或多个整数整除的最小正整数。如果`lcm(a, b) = m`, 那么`m % a== 0`、`m % b == 0`, 且不存在比`m`更小的数满足上边的情况。

**最小公倍数和最大公约数之间有关系, `lcm(a, b) * gcd(a, b) = a * b`, 即两个数的乘积等于它们的最大公约数与最小公倍数的乘积**。

```cpp
int gcd(int a, int b)
{
    if (a <  b) { 
        // swap算法
        int temp = a;
        a = b;
        b = temp;
    }

    // 采用递归的方式
    if (b == 0)
    {
        return a;
    }
    return gcd(b, a % b);
}

int lcd(int a, int b)
{
    // 防止溢出, 先做除法操作
    return (a / gcd(a, b)) * b;
}
```
